{
  "README.html": {
    "href": "README.html",
    "title": "API Anatomy | API Anatomy",
    "keywords": "API Anatomy This repository is an attempt at defining a set of application level terminology for HTTP API design. Along with each term is a description and an OpenAPI description of an example API demonstrating its use. The intent of this collection is not to suggest best practices but to be a set of scenario examples that tooling developers can use to verify that they provide broad support for API designers. Resource Design A HTTP API is a set of resources, identified by URL, that share a common base URL. A HTTP API is a set of resources that a consumer interacts with to achieve some desired objective. Each resource is identified by a URI. That's why it is called a Universal Resource Identifier. All resources in a HTTP API share a common base URL. Most API designers these days use just the path portion of the URL to identify the domain concept of interest. The authority part, i.e. schema and host, are just used to identify where the service is deployed, and the query parameters are used to manipulate the response in some way to change how the domain concept is presented. Path segments Kind Description Category Organizational segment used to group related resources together in the hierarchy. e.g. https://example.org/accounting/invoices Data Partition Segment used to partition different sets of similarly structured data. e.g. https://example.org/acme/employees Version Segment used to partition resource hierarchies due to breaking changes in resource structure or behavior. e.g. https://example.org/v1/users Key/value pair A segment pair used to attach some value to resources in the sub hierarchy. e.g. https://example.org/subscription/XHJSD-JSDS-UERJE/resources Collection A segment used to indicate a set of some domain concept. e.g. https://example.org/movies Item A segment used to indicate a specific instance of some domain concept within a set. e.g. https://example.org/movies/some-movie-id Relationship A segment used to indicate a relationship between one domain concept and another. e.g. https://example.org/movies/some-movie-id/actors Multi-segment A set of segments used to allow API consumers to define a hierarchy for a set of domain concepts. e.g. https://example.org/bookmarks/personal/cooking/testkitchen Matrix A rarely used capability to insert a multi-dimensional table of domain concepts into a hierarchy. e.g. https://example.org/countries;continent=asia/cities View A path segment used to explicitly indicate an alternate resource for the same domain concept. e.g. https://example.org/recipies/eggnog;printable Action A segment used to perform an unsafe operation on either a related resource or some kind of data processing on the transfered information. https://example.org/me/invites/accept Function A segment used create results that are usually an aggregation of domain concepts or some derivative of a domain concept. https://example.org/me/documents/recentlyUsed Behavior The set of path segments defines a hierarchy. Path segments provide context to the following segments. This can have a significant impact for some types of path segment. A version segment at the far left of a path, has a very different impact than one at the far right of the path. The hierarchial nature of a path is the major differentiator between path segments and query parameters. Query parameters Query parameters are used to create variants of the resource identified by the path. Each of these variants is technically a resource on its own as it has a distinct URL. However, generally, variants created by query parameters will share many of the same characteristics of the resource identified by just the path. Kind Description Projection Identifies a resource that contains a subset of the information contained in the path-only resource. Consider this a vertical slice of the path-only resource. https://example.org/books?select=Title,Author Filtering Identifies a resource that contains a subset of the items from of the path-only resource. Consider this a horizontal slide of the path-only resource. e.g. http://example.org/books?author=Smith| Sorting Identifies a resource that contains a set of items from the path-only resource in some specified order. e.g. https://example.org/tasks?orderBy=Deadline Range Identifies a resource that contains a subset of items from the path-only resource based on a ordinal constraints. e.g. https://example.org/tasks?top=10&skip=50 Transclusion Enables a caller to include a representation of a related resource into the representation of the path-only resource. e.g. https://example.org/users/22?$expand=manager Sparse identifiers Identifies a resource using n property values within a n-space. e.g. https://example.org/map/image?lat=100&long=50 Behavior modifiers Identifies a resource that is a variant of the path-only resource in some domain specific way. e.g. https://example.org/me/calendar?view=week Representation format Identifies a resource that is a variant of the path-only resource in the format of the reprentation. e.g. https://example.org/me/tasks?format=CSV URLs are serialized as strings when being used by HTTP. However, the values used for parameters in the URL often have additional semantics that do not have standardized string serializations. Parameter Type Serialization Notes strings Serialization examples include: apple or \"apple\" or 'apple' arrays of strings Some examples of ways that arrays of strings can be represented include: \"apple,banana,pear\" or [\"apple\",\"banana\",\"pear\"] or apple,banana,pear expressions Examples in query parameters include filter=fruit eq \"apple\" and filter[fruit]=apple json dynamic form data dates ISO, unix numbers Constrained types enums? Behavior Beyond the kind of parameters and data types of individual parameters, there are often dependencies between parameters that appear in a URL. Type Serialization Notes Optional parameters Optional path parameters can be challenging unless they are a key/value segment pair. Query parameters are commonly optional. Making query parameters required is a burden on client applications and can introduce challenges with relative references. Dependent parameters Due to the natural hierarchy of path segments, path parameters are frequently dependent on the value of parameters higher in the hierarchy. Interdependencies between query parameters are possible, but they are difficult to describe in metadata and hard to enforce in client code. Parameter ordering Most APIs do not enforce any ordering of query parameters. However, technically, different parameter orders are different URLs and therefore different resources. This mainly affects intermediaries like caches, that need to do some normalization to prevent multiple copies of representations. Parameter name casing Query parameter names are technically case sensitive, but in practice they rarely are. Intermediaries will often need to normalize URLs to determine a canonical URL. Encoding issues Requests Feature Description Prefer header The prefer request header can be used for a variety of purposes including suggesting the size of response representation to be returned, or to indicate a preference for a long running operation. Accept An accept header can be used by a client to request different representations (i.e. different media types) of the same resource. This is often also achieved using a query parameter. Idempotency Some HTTP interactions are by definition idepempotent. Others can be made idempotent by including a unique value in the request. This can be important for requests that must only execute once, even with an unreliable network. Authenticated Interactions Some resources should only be accessible by clients that have the appropriate authentication. Ideally, the Authorization HTTP header is used for this. There are some alterative solutions for certain circumstances. Paid interactions API providers sometimes choose to charge for a client to make an API request. APIs should indicate when a payment mechanism must be provided. Identifiers of payment mechanisms can be provided in the request, or can be tied to an authenticated identity. Detecting changes in data API consumers often want to retrieve changes to a resource, since some prior point in time. There are a variety of ways this can be achieved. Tunneled requests This is sometimes an anti-pattern where part of the request message, either headers or body, is used to identity what could be identified in the URL. There may be valid reasons for doing this but it is important to understand the trade-offs of not identifying the distinct resources via the URL. Batches Batching is an application level solution to being able to make multiple requests in a single HTTP message. This can be a performance optimization for HTTP/1.1 based requests due to the limited number of TCP/IP connections allowed from some clients. However, it is rarely the right solution when using HTTP/2. Responses Feature Description Redirects Throttling Long running NoContent or Content Some HTTP interactions return a representation of the resource that is being interacted with, others do not. Whether content is returned or not is generally based on a combination of the method and the status code. Partial failure Redirects Cachable content Deleted Representation Design Feature Description Media types Multi format responses Batch Polymorphic responses Null vs absence Deprecation Collections vs items Facets Annotations Links Other Security Privacy Workflow (sequences of requests) Errors"
  },
  "mediatypes/DOMFactory-pattern.html": {
    "href": "mediatypes/DOMFactory-pattern.html",
    "title": "DOM Factory Pattern | API Anatomy",
    "keywords": "DOM Factory Pattern A pattern for serializing and deserializing structured documents that is resilient to the evolution of the document structure and the serialization syntax. Motivation Inter-process and network communication is prevalent in almost every piece of software today. Software applications talk to each other using application protocols that communicate messages. Those messages must be serialized and deserialized into order to be passed between applications. As software evolves the contents and shape of the message can change to meet new requirements or solve discovered problems. Changing messages has the potential to force changes in the all the software components that process those messages. The DOMFactory pattern aims to minimize the impact of those changes by centralizing the logic that understands the nature of those changes in order to eliminate the need for other components to contain that logic. It is the responsibility of the owner of the message to encapsulate the changes made in different versions of the message so that consumers of the message only ever have to work with one version of the message. This enables consuming applications to transparently handle all previous versions. graph LR messagev1 -->|deserialize| messageDOMFactory messagev2 -->|deserialize| messageDOMFactory messagev3 -->|deserialize| messageDOMFactory messageDOMFactory -->|create| messageDOMv3 messageDOMv3 --> |uses| consumerApp This pattern also enables producer applications to generate previous versions (sometimes lossy) to drive consumer applications that do not yet support the latest version of the message. graph LR producerApp -->|creates| messageDOMv3 messageDOMv3 -->|serialize| messagev1 messageDOMv3 -->|serialize| messagev2 messageDOMv3 -->|serialize| messagev3 Problem Statement Writing custom parsing and deserialization code for every message type requires a significant amount of code that is performance and security sensitive. To address this, most programming languages have developed generic libraries that can take a serialized message in a known format like JSON, XML or YAML and automatically translate it into a provided language type. This enables application developers to create language types that mirror the shape of the message and the automatic (de)serialization libraries are able to introspect the structure of the type and infer the mapping of the message to the type. Where there is missing metadata, annotations can be applied to the language type to guide the mapping. These automatic deserialization libraries usually have a set of global settings that allow expressing preferences that impact how values are maps because not every developer uses the same set of conventions when it comes to serialization. Examples of this for JSON, include character casing of object member names, format of dates, currencies and null object handling. With the convenience of automatic (de)serializers, the responsibility of message deserialization is usually left to the application developer who is consuming or producing the message. However, when messages evolve, it becomes the responsibility of every application developer who produces or consumes that message to change their application code. For any non-trivial change it is likely that the automatic (de)serializer library will need to have a mirror type for each version of the message. This requires an app developer to at least partially read the message to discover the version of the message so it can select the right language type to deserialize, unless the version is passed out of band, or the application only chooses to support a single version. These challenges with handling multiple versions of a document lead producers and consumers to be slow to adopt new versions for fear of impacting existing partners, or when they do change they quickly drop support for the old versions due to application complexity. A worse outcome is when only partial features of a new version are supported so as to address immediate needs but without fully supporting that version. This leads to significant user confusion when validating messages. Solution Overview The vast majority of application defined messages are based on standard generic formats such as JSON, XML and YAML. This pattern attempts to address the problems described by breaking (de)serialization down into two distinct parts: translating between the serialized wire format and a syntax DOM based on the underlying document format. e.g. JSON translating between the syntax DOM (e.g. JsonDocument) and the application DOM (e.g. BankTransferV1) Format Parsing Using existing libraries for parsing the base format (e.g. JSON, XML or YAML) in the target language provides a secure and efficient way of converting the wire format into a base format DOM that can be processed. This standardization of formats like JSON, XML and YAML ensures a consistent interpretation of the wire format that is properly validated against the standard. graph LR JSONString(Json String) --> |Native Library| JSONDOM(JSON DOM) Application Domain Parsing Once the base format DOM has been produced, it is traversed and the corresponding domain specific objects are created and populated with values that have are extracted from the base format DOM. graph LR JSONDOM(JSON DOM) --> |Mapping Code| DomainObject(Domain Object) The mapping code can be written by hand or generated, based on schemas, for complex documents. AI based assistants have proven very effective at suggesting the mapping code once they have seen a few examples and have example messages to work from. Structure of the Pattern The pattern requires creating model classes and members that represent the content of the message. Each class requires the following elements: consumer factory: a constructor or static factory method that accepts an compatible node from the base format syntax. producer factory: a constructor or static factory method that enables creating the model independently of a message. writer: A method that will serialize the object into passed base format document writer. handlers: A member that holds a dictionary of actions where the wire format member name is the key. Consider the following JSON message: { \"property\": \"value\", \"element\": { \"property\": 10 } } The following model objects would be required to represent the contents of the message. classDiagram class MessageDocument { -handlers Dictionary&lt;string, action&gt; string Property ctor(JsonElement value) ctor() Write(Utf8JsonWriter writer) void } MessageDocument *--> MessageElement class MessageElement { -handlers Dictionary&lt;string, action&gt; int Property ctor(JsonElement value) ctor() Write(Utf8JsonWriter writer) void } If the handlers dictionary is static, then the action must accept an instance of the target model object as well as source base format DOM object. Implementation Details Once a wire format representation is deserialized into a base format DOM, such as a JsonDocument object, it is passed to the consumer factory method of the root model object to initiate the mapping of values from the base format DOM to the model objects. Consumer Factory Responsibilities The consumer factory must create an instance of the target model object and then iterate through the members of the current base format DOM node, processing each member. If that node corresponds to a JsonObject then a helper method such as this can be used to execute the handler for each member in the JsonObject against the model instance. public static void ParseMap<T>(JsonElement node, T document, Dictionary<string, Action<T, JsonElement>> handlers) { foreach (var element in node.EnumerateObject()) { handlers[element.Name](document, element.Value); }; } This method execute handlers for known members and will fail if a member exists in the wire format that is not recognized. Support for fields that match patterns can be added by testing the handler collection first. A secondary set of handlers can be provided for pattern matching. Handlers Each handler in the dictionary of handlers provide an action (aka lambda) that will transfer information from a base format DOM node to a property of the object model. The key for the handler is the identifier used in the base format DOM. The action accepts the base format DOM node and in some cases the model object instance created by the consumer factory. Writer Every model object requires a writer method that will accept a base format writer. The method writes the contents of the model object into the passed writer. Examples Example of a root model object in C# that uses constructors for the producer factory and consumer factory. The following examples use some helper methods to avoid repetitive code in the handler actions and factory methods. public class ApiManifestDocument { public Publisher? Publisher { get; set; } public string? ApplicationName { get; set; } public ApiDependencies ApiDependencies { get; set; } = new ApiDependencies(); public Extensions Extensions { get; set; } = new Extensions(); private const string PublisherProperty = \"publisher\"; private const string ApplicationNameProperty = \"applicationName\"; private const string ApiDependenciesProperty = \"apiDependencies\"; private const string ExtensionsProperty = \"extensions\"; public ApiManifestDocument(string applicationName) { ApplicationName = applicationName; Validate(); } public ApiManifestDocument(JsonElement value) { ParsingHelpers.ParseMap(value, this, handlers); Validate(); } // Write method public void Write(Utf8JsonWriter writer) { ValidationHelpers.ThrowIfNull(writer, nameof(writer)); Validate(); writer.WriteStartObject(); writer.WriteString(ApplicationNameProperty, ApplicationName); if (Publisher != null) { writer.WritePropertyName(PublisherProperty); Publisher.Write(writer); } if (ApiDependencies.Any()) { writer.WritePropertyName(ApiDependenciesProperty); writer.WriteStartObject(); foreach (var apiDependency in ApiDependencies) { writer.WritePropertyName(apiDependency.Key); apiDependency.Value.Write(writer); } writer.WriteEndObject(); } if (Extensions.Any()) { writer.WritePropertyName(ExtensionsProperty); Extensions.Write(writer); } writer.WriteEndObject(); } // Load method public static ApiManifestDocument Load(JsonElement value) { return new ApiManifestDocument(value); } internal void Validate() { ValidationHelpers.ValidateNullOrWhitespace(nameof(ApplicationName), ApplicationName, nameof(ApiManifestDocument)); Publisher?.Validate(); } // Create fixed field map for ApiManifest private static readonly FixedFieldMap<ApiManifestDocument> handlers = new() { { ApplicationNameProperty, (o,v) => {o.ApplicationName = v.GetString(); } }, { PublisherProperty, (o,v) => {o.Publisher = Publisher.Load(v); } }, { ApiDependenciesProperty, (o,v) => {o.ApiDependencies = new ApiDependencies(ParsingHelpers.GetMap(v, ApiDependency.Load)); } }, { ExtensionsProperty, (o,v) => {o.Extensions = Extensions.Load(v); } } }; } https://github.com/microsoft/openapi.apimanifest Example of a child model object in C# that uses a static factory method instead of constructor as a consumer factory. public class Permission { public string Note { get; set; } public bool Implicit { get; set; } = false; public string PrivilegeLevel { get; set; } public SortedDictionary<string, Scheme> Schemes { get; set; } = new SortedDictionary<string, Scheme>(); public List<PathSet> PathSets { get; set; } = new List<PathSet>(); public OwnerInfo OwnerInfo { get; set; } = new(); public void Write(Utf8JsonWriter writer) { writer.WriteStartObject(); if (!string.IsNullOrWhiteSpace(Note)) writer.WriteString(\"note\", Note); if (Implicit) writer.WriteBoolean(\"implicit\", Implicit); writer.WritePropertyName(\"schemes\"); writer.WriteStartObject(); foreach (var scheme in Schemes) { writer.WritePropertyName(scheme.Key.ToString()); scheme.Value.Write(writer); } writer.WriteEndObject(); writer.WritePropertyName(\"pathSets\"); writer.WriteStartArray(); foreach (var pathSet in PathSets) { pathSet.Write(writer); } writer.WriteEndArray(); writer.WritePropertyName(\"ownerInfo\"); OwnerInfo.Write(writer); writer.WriteEndObject(); } internal static Permission Load(JsonElement value) { var permission = new Permission(); ParsingHelpers.ParseMap(value, permission, handlers); return permission; } private static FixedFieldMap<Permission> handlers = new() { { \"note\", (o,v) => {o.Note = v.GetString(); } }, { \"privilegeLevel\", (o,v) => {o.PrivilegeLevel= v.GetString(); } }, { \"implicit\", (o,v) => {o.Implicit = v.GetBoolean(); } }, { \"pathSets\", (o,v) => {o.PathSets = ParsingHelpers.GetList(v, PathSet.Load); } }, { \"schemes\", (o,v) => {o.Schemes = ParsingHelpers.GetOrderedMap(v, Scheme.Load); } }, { \"ownerInfo\", (o,v) => {o.OwnerInfo = OwnerInfo.Load(v); } }, }; } https://github.com/microsoftgraph/kibali/blob/main/src/kibali/Permission.cs For object models that have a complex inheritance hierarchy there may be benefits to creating the dictionary of handlers from an object instance rather than having it as a static dictionary. public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers() { return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers()) { {\"attachmentSessions\", n => { AttachmentSessions = n.GetCollectionOfObjectValues<AttachmentSession>(AttachmentSession.CreateFromDiscriminatorValue)?.ToList(); } }, {\"attachments\", n => { Attachments = n.GetCollectionOfObjectValues<AttachmentBase>(AttachmentBase.CreateFromDiscriminatorValue)?.ToList(); } }, {\"body\", n => { Body = n.GetObjectValue<ItemBody>(ItemBody.CreateFromDiscriminatorValue); } }, {\"bodyLastModifiedDateTime\", n => { BodyLastModifiedDateTime = n.GetDateTimeOffsetValue(); } }, {\"categories\", n => { Categories = n.GetCollectionOfPrimitiveValues<string>()?.ToList(); } }, {\"checklistItems\", n => { ChecklistItems = n.GetCollectionOfObjectValues<ChecklistItem>(ChecklistItem.CreateFromDiscriminatorValue)?.ToList(); } }, {\"completedDateTime\", n => { CompletedDateTime = n.GetObjectValue<DateTimeTimeZone>(DateTimeTimeZone.CreateFromDiscriminatorValue); } }, {\"createdDateTime\", n => { CreatedDateTime = n.GetDateTimeOffsetValue(); } }, {\"dueDateTime\", n => { DueDateTime = n.GetObjectValue<DateTimeTimeZone>(DateTimeTimeZone.CreateFromDiscriminatorValue); } }, {\"extensions\", n => { Extensions = n.GetCollectionOfObjectValues<Extension>(Extension.CreateFromDiscriminatorValue)?.ToList(); } }, {\"hasAttachments\", n => { HasAttachments = n.GetBoolValue(); } }, {\"importance\", n => { Importance = n.GetEnumValue<Importance>(); } }, {\"isReminderOn\", n => { IsReminderOn = n.GetBoolValue(); } }, {\"lastModifiedDateTime\", n => { LastModifiedDateTime = n.GetDateTimeOffsetValue(); } }, {\"linkedResources\", n => { LinkedResources = n.GetCollectionOfObjectValues<LinkedResource>(LinkedResource.CreateFromDiscriminatorValue)?.ToList(); } }, {\"recurrence\", n => { Recurrence = n.GetObjectValue<PatternedRecurrence>(PatternedRecurrence.CreateFromDiscriminatorValue); } }, {\"reminderDateTime\", n => { ReminderDateTime = n.GetObjectValue<DateTimeTimeZone>(DateTimeTimeZone.CreateFromDiscriminatorValue); } }, {\"startDateTime\", n => { StartDateTime = n.GetObjectValue<DateTimeTimeZone>(DateTimeTimeZone.CreateFromDiscriminatorValue); } }, {\"status\", n => { Status = n.GetEnumValue<TaskStatus>(); } }, {\"title\", n => { Title = n.GetStringValue(); } }, }; } https://github.com/microsoftgraph/msgraph-sdk-dotnet/blob/dev/src/Microsoft.Graph/Generated/Models/TodoTask.cs and the equivalent in Java https://github.com/microsoftgraph/msgraph-sdk-java/blob/f2960ba4d02bb15a01a9b2750d43c5e978eb21b4/src/main/java/com/microsoft/graph/generated/models/TodoTask.java#L113 In this particular example, the models are generated from a schema. The actions in the handler dictionary only accept a single parameter because the target model instance is closed over by the lambda."
  },
  "methods.html": {
    "href": "methods.html",
    "title": "HTTP Methods | API Anatomy",
    "keywords": "HTTP Methods API consumers interact with resources in an API using HTTP Methods. There is a limited set of supported HTTP methods that can be reused across many resources. Not every resource supports every method. graph LR GET --> g200[200] --> Get GET --> g200[200] --> Function GET --> g204[204] --> Ping GET --> g202[202] --> Report POST --> po201[201] --> Create POST --> po200[200] --> Action POST --> po204[204] --> FireAndForget POST --> po202[202] --> Job PUT --> pu200[200] --> Replace PUT --> pu204[204] --> ReplaceNoResponse PUT --> pu200-201[200,201] --> ReplaceOrCreate PATCH --> pa200-201[200,201] --> UpdateOrCreate PATCH --> pa200-201-204[200,201,204] --> UpdateOrCreateNoResponse"
  },
  "models/polymorphic.html": {
    "href": "models/polymorphic.html",
    "title": "Polymorphic Responses | API Anatomy",
    "keywords": "Polymorphic Responses Representing inheritance Inline schemas with a single allOf for the base type Array of anyOfs with one being the base type (why oneOf is likely wrong) Simulating inheritance using allOf. components: schemas: cat: type: object allOf: - $ref: \"#/components/schemas/animal\" animal: type: object properties: species: type: string Any allOf constraint with a single $ref array member is considered a declaration of a base type. Given a schema If schema is a component type, name equals component name else type name is generated based on some context If schema contains allOf and other \"important properties???\", 2a. If allOf has one child schema that is a $ref, $ref points to base type else merge the allOfs into the current type 2b. if schema contains oneOf. Throw up hands. if schema contains oneOf or anyOf 4a. create wrapper class called ??? 4b. Create properties that correstpond to child schemas - primitives use the type name - objects use the paths and other context to construct \"best possible names\". Still to investigate: Nested allOfs allOf primitive types? Should anyOf and oneOf be treated different for modelling Kiota => anyOf with shared properties actually deserialize the property twice. Proposing new keywords components: schemas: foo: allOfAsExtends: # inheritance - $ref: '#/components/schemas/base' - $ref: '#/components/schemas/Otherbase' allOf: # spread - $ref: '#/components/schemas/creationInfo' Simulating using anyOf.. paths: /felines/{id}: responses: 200: description: ok schema: title: feline anyOf: - $ref: \"#/components/animal\" - $ref: \"#/components/cat\" - $ref: \"#/components/tiger\" components: schemas: dog: type: object tiger: type: object cat: type: object animal: type: object properties: species: type: string"
  },
  "models/union-types.html": {
    "href": "models/union-types.html",
    "title": "| API Anatomy",
    "keywords": "Union type with primitives Union type with arrays Union type with objects components: schemas: primitives: oneOf: - type: string - type: number"
  },
  "path/category.html": {
    "href": "path/category.html",
    "title": "Category Path Segment | API Anatomy",
    "keywords": "Category Path Segment For large APIs with many resources it is often useful to group related resources under a category path segment. Generally this kind of path segment would appear early in the URL. openapi: 3.0.3 info: title: \"Accounting path segment used to group related resources\" version: \"1.0.0\" servers: - url: https://api.example.org/ paths: /accounting/invoices: get: responses: 200: description: ok /accounting/generalLedger: get: responses: 200: description: ok /accounting/accounts: get: responses: 200: description: ok A category segment can be used as an alternative to creating separate APIs for each of the categories."
  },
  "path/collection.html": {
    "href": "path/collection.html",
    "title": "Collection Path Segment | API Anatomy",
    "keywords": "Collection Path Segment Filters ordering collection level actions item relationship PATCH POST"
  },
  "path/data-partition.html": {
    "href": "path/data-partition.html",
    "title": "Data Partition Path Segment | API Anatomy",
    "keywords": "Data Partition Path Segment For SAAS APIs, there is often a unique set of data for each API consumer customer. A data partition path segment can be used to distinguish between data the different sets of data. Using the path to make this distinction in case there is future need to reference data from multiple datasets in a single application. openapi: 3.0.0 info: title: \"Accounting path segment used to group related resources\" version: \"1.0.0\" servers: - url: https://api.example.org/ paths: /{datapartition}/invoices: parameters: - $ref: \"#/components/parameters/datapartition\" get: responses: 200: description: ok /{datapartition}/generalLedger: parameters: - $ref: \"#/components/parameters/datapartition\" get: responses: 200: description: ok /{datapartition}/accounts: parameters: - $ref: \"#/components/parameters/datapartition\" get: responses: 200: description: ok components: parameters: datapartition: name: datapartition in: path required: true schema: type: string As a data partition would generally apply to all resources in an API, it could also be modelled as a aerver variable in OpenAPI. openapi: 3.0.0 info: title: \"Accounting path segment used to group related resources\" version: \"1.0.0\" servers: - url: https://example.org/{datapartition}/ variables: datapartition: default: sandbox description: A sandbox dataset used for testing API calls paths: /invoices: get: responses: 200: description: ok /generalLedger: get: responses: 200: description: ok /accounts: get: responses: 200: description: ok One disadvantage of this approach is that it is OpenAPI does not provide rich facilities facilities for describing as server variable, like it does for parameters."
  },
  "path/function.html": {
    "href": "path/function.html",
    "title": "| API Anatomy",
    "keywords": ""
  },
  "path/item.html": {
    "href": "path/item.html",
    "title": "Item key path parameters | API Anatomy",
    "keywords": "Item key path parameters"
  },
  "path/key-value-pair.html": {
    "href": "path/key-value-pair.html",
    "title": "Key Value Pair Path Segments | API Anatomy",
    "keywords": "Key Value Pair Path Segments"
  },
  "path/matrix.html": {
    "href": "path/matrix.html",
    "title": "Matrix Parameters in a Path Segment | API Anatomy",
    "keywords": "Matrix Parameters in a Path Segment"
  },
  "path/multi-segment.html": {
    "href": "path/multi-segment.html",
    "title": "Multi-segment path parameters | API Anatomy",
    "keywords": "Multi-segment path parameters"
  },
  "path/relationship.html": {
    "href": "path/relationship.html",
    "title": "Relationship Path Segmnent | API Anatomy",
    "keywords": "Relationship Path Segmnent It is common for resources in an API to have some kind of relationship such as \"parent-child\" or \"has a\" relationship."
  },
  "path/version.html": {
    "href": "path/version.html",
    "title": "Version Path Segment | API Anatomy",
    "keywords": "Version Path Segment It is common for APIs to be designed with one of the left-most path segments being reserved for a version identifier. Numerous API design guidelines describe this as a best practice. It does make it easier for the API provider to introduce a significant amount of breaking changes, however the burden is transfered to the API consumer who must accomodate all the new changes in order to take advantage of any new change. openapi: 3.0.3 info: title: \"Version path segment at the front\" version: \"1.0.0\" servers: - url: https://api.example.org/ paths: /{version}/invoices: get: responses: 200: description: ok /{version}/customers: get: responses: 200: description: ok If the version segment is the left most path segment and is used for all paths, it can be represented as a server variable. openapi: 3.0.3 info: title: \"Version path segment at the front\" version: \"1.0.0\" servers: - url: https://api.example.org/{version}/ variables: version: default: \"1.0\" enum: - \"1.0\" - \"2.0\" paths: /invoices: get: responses: 200: description: ok /customers: get: responses: 200: description: ok"
  }
}